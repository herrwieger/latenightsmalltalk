Object subclass: #TestCase	instanceVariableNames: 'testSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Kernel'!!TestCase methodsFor: 'accessing' stamp: 'md 8/2/2006 10:59'!assert: aBooleanOrBlock	aBooleanOrBlock value ifFalse: [self signalFailure: 'Assertion failed']			! !!TestCase methodsFor: 'accessing' stamp: 'md 8/2/2006 11:00'!assert: aBooleanOrBlock description: aString	aBooleanOrBlock value ifFalse: [		self logFailure: aString.		TestResult failure signal: aString]			! !!TestCase methodsFor: 'accessing' stamp: 'md 8/2/2006 11:00'!assert: aBooleanOrBlock description: aString resumable: resumableBoolean 	| exception |	aBooleanOrBlock value		ifFalse: 			[self logFailure: aString.			exception := resumableBoolean						ifTrue: [TestResult resumableFailure]						ifFalse: [TestResult failure].			exception signal: aString]			! !!TestCase methodsFor: 'accessing' stamp: 'md 8/2/2006 11:00'!deny: aBooleanOrBlock	self assert: aBooleanOrBlock value not			! !!TestCase methodsFor: 'accessing' stamp: 'md 8/2/2006 11:00'!deny: aBooleanOrBlock description: aString	self assert: aBooleanOrBlock value not description: aString			! !!TestCase methodsFor: 'accessing' stamp: 'md 8/2/2006 11:00'!deny: aBooleanOrBlock description: aString resumable: resumableBoolean 	self		assert: aBooleanOrBlock value not		description: aString		resumable: resumableBoolean			! !!TestCase methodsFor: 'accessing'!resources	| allResources resourceQueue |	allResources := Set new.	resourceQueue := OrderedCollection new.	resourceQueue addAll: self class resources.	[resourceQueue isEmpty] whileFalse: [		| next |		next := resourceQueue removeFirst.		allResources add: next.		resourceQueue addAll: next resources].	^allResources			! !!TestCase methodsFor: 'accessing'!selector	^testSelector			! !!TestCase methodsFor: 'accessing'!should: aBlock	self assert: aBlock value			! !!TestCase methodsFor: 'accessing'!should: aBlock description: aString	self assert: aBlock value description: aString			! !!TestCase methodsFor: 'accessing'!should: aBlock raise: anExceptionalEvent 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)			! !!TestCase methodsFor: 'accessing'!should: aBlock raise: anExceptionalEvent description: aString 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)		description: aString			! !!TestCase methodsFor: 'accessing' stamp: 'nk 5/11/2003 10:32'!should: aBlock raise: anExceptionalEvent whoseDescriptionDoesNotInclude: subString description: aString 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionNotContaining: subString)		description: aString! !!TestCase methodsFor: 'accessing' stamp: 'nk 5/11/2003 10:24'!should: aBlock raise: anExceptionalEvent whoseDescriptionIncludes: subString description: aString 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionContaining: subString)		description: aString! !!TestCase methodsFor: 'accessing'!shouldnt: aBlock	self deny: aBlock value			! !!TestCase methodsFor: 'accessing'!shouldnt: aBlock description: aString	self deny: aBlock value description: aString			! !!TestCase methodsFor: 'accessing'!shouldnt: aBlock raise: anExceptionalEvent 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not			! !!TestCase methodsFor: 'accessing'!shouldnt: aBlock raise: anExceptionalEvent description: aString 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString			! !!TestCase methodsFor: 'accessing' stamp: 'nk 5/11/2003 10:34'!shouldnt: aBlock raise: anExceptionalEvent whoseDescriptionDoesNotInclude: subString description: aString 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionNotContaining: subString) not		description: aString! !!TestCase methodsFor: 'accessing' stamp: 'nk 5/11/2003 10:34'!shouldnt: aBlock raise: anExceptionalEvent whoseDescriptionIncludes: subString description: aString 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionContaining: subString) not		description: aString! !!TestCase methodsFor: 'accessing' stamp: 'md 2/22/2006 14:26'!signalFailure: aString	TestResult failure signal: aString! !!TestCase methodsFor: 'dependencies'!addDependentToHierachy: anObject 	"an empty method. for Composite compability with TestSuite"			! !!TestCase methodsFor: 'dependencies'!removeDependentFromHierachy: anObject 	"an empty method. for Composite compability with TestSuite"			! !!TestCase methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: self class printString;		nextPutAll: '>>#';		nextPutAll: testSelector			! !!TestCase methodsFor: 'running' stamp: 'md 2/22/2006 14:27'!debug	self resources do: [:res | 		res isAvailable ifFalse: [^res signalInitializationError]].	[(self class selector: testSelector) runCase] 		ensure: [self resources do: [:each | each reset]]			! !!TestCase methodsFor: 'running' stamp: 'bp 11/15/2004 18:13'!debugAsFailure	| semaphore |	semaphore := Semaphore new.	self resources do: [:res | 		res isAvailable ifFalse: [^res signalInitializationError]].	[semaphore wait. self resources do: [:each | each reset]] fork.	(self class selector: testSelector) runCaseAsFailure: semaphore.! !!TestCase methodsFor: 'running' stamp: 'md 2/22/2006 14:17'!failureLog		^Transcript			! !!TestCase methodsFor: 'running'!isLogging	"By default, we're not logging failures. If you override this in 	a subclass, make sure that you override #failureLog"	^false			! !!TestCase methodsFor: 'running'!logFailure: aString	self isLogging ifTrue: [		self failureLog 			cr; 			nextPutAll: aString; 			flush]			! !!TestCase methodsFor: 'running' stamp: 'bp 11/15/2004 18:17'!openDebuggerOnFailingTestMethod	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 	 send into 'self perform: testSelector' to see the failure from the beginning"	self notImplementedYet.	self performTest! !!TestCase methodsFor: 'running'!run	| result |	result := TestResult new.	self run: result.	^result			! !!TestCase methodsFor: 'running'!run: aResult	aResult runCase: self			! !!TestCase methodsFor: 'running' stamp: 'md 2/22/2006 14:27'!runCase	[self setUp.	self performTest] ensure: [self tearDown]			! !!TestCase methodsFor: 'running' stamp: 'md 2/22/2006 14:27'!runCaseAsFailure: aSemaphore	[self setUp.	self openDebuggerOnFailingTestMethod] ensure: [		self tearDown.		aSemaphore signal]! !!TestCase methodsFor: 'running'!setUp			! !!TestCase methodsFor: 'running'!tearDown			! !!TestCase methodsFor: 'testing' stamp: 'JF 7/30/2003 13:40'!expectedFailures	^ Array new! !!TestCase methodsFor: 'testing' stamp: 'JF 7/30/2003 13:39'!shouldPass	"Unless the selector is in the list we get from #expectedFailures, we expect it to pass"	^ (self expectedFailures includes: testSelector) not! !!TestCase methodsFor: 'private' stamp: 'md 2/22/2006 14:27'!executeShould: aBlock inScopeOf: anExceptionalEvent 	^[aBlock value. 	false] on: anExceptionalEvent		do: [:ex | ex return: true]			! !!TestCase methodsFor: 'private' stamp: 'md 2/22/2006 14:27'!executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionContaining: aString	^[aBlock value. 	false] on: anExceptionalEvent		do: [:ex | ex return: (ex description includesSubString: aString) ]			! !!TestCase methodsFor: 'private' stamp: 'md 2/22/2006 14:27'!executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionNotContaining: aString	^[aBlock value. 	false] on: anExceptionalEvent		do: [:ex | ex return: (ex description includesSubString: aString) not ]			! !!TestCase methodsFor: 'private' stamp: 'md 2/22/2006 14:22'!performTest	self perform: testSelector asSymbol.			! !!TestCase methodsFor: 'private'!setTestSelector: aSymbol	testSelector := aSymbol			! !!TestCase methodsFor: 'extensions' stamp: 'mx 3/20/2006 23:32'!executeShould: aBlock inScopeOf: anException withExceptionDo: anotherBlock	^[aBlock value. 	false] 		on: anException		do: [:exception | 			anotherBlock value: exception.			exception return: true]! !!TestCase methodsFor: 'extensions' stamp: 'mx 3/13/2006 23:21'!fail	^self assert: false! !!TestCase methodsFor: 'extensions' stamp: 'mx 3/20/2006 21:29'!shouldFix: aBlock 	^self should: aBlock raise: Exception! !!TestCase methodsFor: 'extensions' stamp: 'mx 3/20/2006 23:52'!should: aBlock raise: anException withExceptionDo: anotherBlock 	^self assert: (self executeShould: aBlock inScopeOf: anException withExceptionDo: anotherBlock)! !!TestCase class methodsFor: 'accessing' stamp: 'md 2/22/2006 14:28'!allTestSelectors	^self allSelectors asSortedCollection asOrderedCollection select: [:each | 		('test*' match: each) and: [each numArgs isZero]]			! !!TestCase class methodsFor: 'accessing'!resources	^ self notImplementedYet. "todo #()"			! !!TestCase class methodsFor: 'accessing'!sunitVersion	^'3.1'			! !!TestCase class methodsFor: 'accessing' stamp: 'md 2/22/2006 14:29'!testSelectors 	^self selectors asSortedCollection asOrderedCollection select: [:each | 		('test*' match: each) and: [each numArgs isZero]]			! !!TestCase class methodsFor: 'building suites' stamp: 'stephaneducasse 2/3/2006 22:41'!addTestsFor: classNameString toSuite: suite	| cls  |	cls := Smalltalk at: classNameString ifAbsent: [ ^suite ].	^cls isAbstract 		ifTrue:  [			cls allSubclasses do: [ :each |				each isAbstract ifFalse: [					each addToSuiteFromSelectors: suite ] ].			suite]		ifFalse: [ cls addToSuiteFromSelectors: suite ]! !!TestCase class methodsFor: 'building suites' stamp: 'nk 4/21/2002 16:37'!addToSuiteFromSelectors: suite	^self addToSuite: suite fromMethods: (self shouldInheritSelectors		ifTrue: [ self allTestSelectors ]		ifFalse: [self testSelectors ])! !!TestCase class methodsFor: 'building suites' stamp: 'nk 4/21/2002 10:51'!addToSuite: suite fromMethods: testMethods 	testMethods do:  [ :selector | 			suite addTest: (self selector: selector) ].	^suite! !!TestCase class methodsFor: 'building suites' stamp: 'stephaneducasse 2/3/2006 22:41'!buildSuite	| suite |	suite := TestSuite new.	^ self isAbstract		ifTrue: [			suite name: self name asString.			self allSubclasses				do: [:each | each isAbstract						ifFalse: [each addToSuiteFromSelectors: suite]].			suite]		ifFalse: [self addToSuiteFromSelectors: suite]! !!TestCase class methodsFor: 'building suites'!buildSuiteFromAllSelectors	^self buildSuiteFromMethods: self allTestSelectors			! !!TestCase class methodsFor: 'building suites'!buildSuiteFromLocalSelectors	^self buildSuiteFromMethods: self testSelectors			! !!TestCase class methodsFor: 'building suites' stamp: 'stephaneducasse 2/3/2006 22:41'!buildSuiteFromMethods: testMethods 	| suite |	suite := (TestSuite new)				name: self name asString;				yourself.	^self addToSuite: suite fromMethods: testMethods! !!TestCase class methodsFor: 'building suites'!buildSuiteFromSelectors	^self shouldInheritSelectors		ifTrue: [self buildSuiteFromAllSelectors]		ifFalse: [self buildSuiteFromLocalSelectors]			! !!TestCase class methodsFor: 'building suites'!suiteClass	^TestSuite			! !!TestCase class methodsFor: 'instance creation'!debug: aSymbol	^(self selector: aSymbol) debug			! !!TestCase class methodsFor: 'instance creation'!run: aSymbol	^(self selector: aSymbol) run			! !!TestCase class methodsFor: 'instance creation'!selector: aSymbol	^self new setTestSelector: aSymbol			! !!TestCase class methodsFor: 'instance creation'!suite	^self buildSuite			! !!TestCase class methodsFor: 'testing' stamp: 'md 2/22/2006 14:21'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self name = #TestCase			! !!TestCase class methodsFor: 'testing'!shouldInheritSelectors	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."	^self superclass isAbstract		or: [self testSelectors isEmpty]"$QA Ignore:Sends system method(superclass)$"			! !Exception subclass: #TestFailure	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Kernel'!!TestFailure methodsFor: 'camp smalltalk' stamp: 'ajh 1/24/2003 19:23'!defaultAction	self notImplementedYet.	"todo Processor activeProcess		debug: self signalerContext		title: self description"! !!TestFailure methodsFor: 'camp smalltalk' stamp: 'ajh 2/1/2003 00:58'!isResumable		^ false! !TestFailure subclass: #ResumableTestFailure	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Kernel'!!ResumableTestFailure methodsFor: 'camp smalltalk'!isResumable	"Of course a ResumableTestFailure is resumable ;-)"	^true! !!ResumableTestFailure methodsFor: 'camp smalltalk'!sunitExitWith: aValue	self resume: aValue! !Object subclass: #TestResource	instanceVariableNames: 'name description'	classVariableNames: 'current'	poolDictionaries: ''	category: 'SUnit-Kernel'!!TestResource methodsFor: 'accessing'!description	description isNil		ifTrue: [^''].	^description			! !!TestResource methodsFor: 'accessing'!description: aString	description := aString			! !!TestResource methodsFor: 'accessing'!name	name isNil		ifTrue: [^self printString].	^name			! !!TestResource methodsFor: 'accessing'!name: aString	name := aString			! !!TestResource methodsFor: 'accessing'!resources	^self class resources			! !!TestResource methodsFor: 'initializing'!initialize	self setUp			! !!TestResource methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self class printString			! !!TestResource methodsFor: 'running'!setUp	"Does nothing. Subclasses should override this	to initialize their resource"			! !!TestResource methodsFor: 'running'!signalInitializationError	^self class signalInitializationError			! !!TestResource methodsFor: 'running'!tearDown	"Does nothing. Subclasses should override this	to tear down their resource"			! !!TestResource methodsFor: 'testing'!isAvailable	"override to provide information on the	readiness of the resource"		^true			! !!TestResource methodsFor: 'testing'!isUnavailable	"override to provide information on the	readiness of the resource"		^self isAvailable not			! !!TestResource class methodsFor: 'accessing'!current	current isNil		ifTrue: [current := self new].	^current			! !!TestResource class methodsFor: 'accessing'!current: aTestResource	current := aTestResource			! !!TestResource class methodsFor: 'accessing'!resources	^self notImplementedYet "#()"			! !!TestResource class methodsFor: 'creation'!reset	current notNil ifTrue: [		[current tearDown] ensure: [			current := nil]]			! !!TestResource class methodsFor: 'creation'!signalInitializationError	^TestResult signalErrorWith: 'Resource ' , self name , ' could not be initialized'			! !!TestResource class methodsFor: 'testing' stamp: 'md 2/22/2006 14:21'!isAbstract	"Override to true if a TestResource subclass is Abstract and should not have	TestCase instances built from it"	^self name = #TestResource			! !!TestResource class methodsFor: 'testing'!isAvailable	^self current notNil and: [self current isAvailable]			! !!TestResource class methodsFor: 'testing'!isUnavailable	^self isAvailable not			! !Object subclass: #TestResult	instanceVariableNames: 'failures errors passed'	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Kernel'!!TestResult methodsFor: 'accessing'!correctCount	"depreciated - use #passedCount"	^self passedCount			! !!TestResult methodsFor: 'accessing'!defects	^OrderedCollection new		addAll: self errors;		addAll: self failures; yourself			! !!TestResult methodsFor: 'accessing'!errorCount	^self errors size			! !!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 13:54'!expectedDefectCount	^ self expectedDefects size! !!TestResult methodsFor: 'accessing' stamp: 'md 11/25/2004 16:36'!expectedDefects	^ (errors, failures asOrderedCollection) select: [:each | each shouldPass not] ! !!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 13:54'!expectedPassCount	^ self expectedPasses size! !!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 16:14'!expectedPasses	^ passed select: [:each | each shouldPass] ! !!TestResult methodsFor: 'accessing'!failureCount	^self failures size			! !!TestResult methodsFor: 'accessing'!passedCount	^self passed size			! !!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 16:07'!runCount	^ passed size + failures size + errors size! !!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 16:06'!tests	^(OrderedCollection new: self runCount)		addAll: passed;		addAll: failures;		addAll: errors;		yourself! !!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 13:54'!unexpectedErrorCount	^ self unexpectedErrors size! !!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 16:14'!unexpectedErrors	^ errors select: [:each | each shouldPass] ! !!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 13:54'!unexpectedFailureCount	^ self unexpectedFailures size! !!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 16:14'!unexpectedFailures	^ failures select: [:each | each shouldPass] ! !!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 13:54'!unexpectedPassCount	^ self unexpectedPasses size! !!TestResult methodsFor: 'accessing' stamp: 'JF 7/30/2003 16:14'!unexpectedPasses	^ passed select: [:each | each shouldPass not] ! !!TestResult methodsFor: 'compatibility' stamp: 'JF 7/30/2003 16:09'!errors	^ self unexpectedErrors! !!TestResult methodsFor: 'compatibility' stamp: 'md 11/25/2004 16:23'!failures	^ self unexpectedFailures, self unexpectedPasses ! !!TestResult methodsFor: 'compatibility' stamp: 'JF 7/30/2003 16:08'!passed	^ self expectedPasses, self expectedDefects! !!TestResult methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/3/2006 22:41'!initialize	passed := OrderedCollection new.	failures := Set new.	errors := OrderedCollection new.! !!TestResult methodsFor: 'printing' stamp: 'JF 7/30/2003 16:15'!printOn: aStream	aStream		nextPutAll: self runCount printString;		nextPutAll: ' run, ';		nextPutAll: self expectedPassCount printString;		nextPutAll: ' passes, ';		nextPutAll: self expectedDefectCount printString;		nextPutAll:' expected failures, ';		nextPutAll: self unexpectedFailureCount printString;		nextPutAll: ' failures, ';		nextPutAll: self unexpectedErrorCount printString;		nextPutAll:' errors, ';		nextPutAll: self unexpectedPassCount printString;		nextPutAll:' unexpected passes'.! !!TestResult methodsFor: 'running' stamp: 'md 2/22/2006 14:27'!runCase: aTestCase	| testCasePassed |	testCasePassed := true.	[[aTestCase runCase] 			on: self class failure			do: 				[:signal | 				failures add: aTestCase.				testCasePassed := false.				signal return: false]]					on: self class error					do:						[:signal |						errors add: aTestCase.						testCasePassed := false.						signal return: false].	testCasePassed ifTrue: [passed add: aTestCase]! !!TestResult methodsFor: 'testing'!hasErrors	^self errors size > 0			! !!TestResult methodsFor: 'testing'!hasFailures	^self failures size > 0			! !!TestResult methodsFor: 'testing' stamp: 'JF 7/30/2003 14:04'!hasPassed	^self runCount = (self passedCount + self expectedDefectCount)! !!TestResult methodsFor: 'testing'!isError: aTestCase	^self errors includes: aTestCase			! !!TestResult methodsFor: 'testing'!isFailure: aTestCase	^self failures includes: aTestCase			! !!TestResult methodsFor: 'testing'!isPassed: aTestCase	^self passed includes: aTestCase			! !!TestResult class methodsFor: 'exceptions'!error	^self exError			! !!TestResult class methodsFor: 'exceptions' stamp: 'md 2/22/2006 14:17'!exError	^Error			! !!TestResult class methodsFor: 'exceptions'!failure	^TestFailure			! !!TestResult class methodsFor: 'exceptions'!resumableFailure	^ResumableTestFailure			! !!TestResult class methodsFor: 'exceptions' stamp: 'md 2/22/2006 14:26'!signalErrorWith: aString 	self error signal: aString			! !!TestResult class methodsFor: 'exceptions' stamp: 'md 2/22/2006 14:26'!signalFailureWith: aString 	self failure signal: aString			! !Object subclass: #TestSuite	instanceVariableNames: 'tests resources name'	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Kernel'!!TestSuite methodsFor: 'accessing'!addTest: aTest	self tests add: aTest			! !!TestSuite methodsFor: 'accessing'!addTests: aCollection 	aCollection do: [:eachTest | self addTest: eachTest]			! !!TestSuite methodsFor: 'accessing'!defaultResources	^self tests 		inject: Set new		into: [:coll :testCase | 			coll				addAll: testCase resources;				yourself]			! !!TestSuite methodsFor: 'accessing'!name	^name			! !!TestSuite methodsFor: 'accessing'!name: aString	name := aString			! !!TestSuite methodsFor: 'accessing'!resources	resources isNil ifTrue: [resources := self defaultResources].	^resources			! !!TestSuite methodsFor: 'accessing'!resources: anObject	resources := anObject			! !!TestSuite methodsFor: 'accessing'!tests	tests isNil ifTrue: [tests := OrderedCollection new].	^tests			! !!TestSuite methodsFor: 'dependencies' stamp: 'md 2/22/2006 14:24'!addDependentToHierachy: anObject	self addDependent: anObject.	self tests do: [ :each | each addDependentToHierachy: anObject]			! !!TestSuite methodsFor: 'dependencies' stamp: 'md 2/22/2006 14:24'!removeDependentFromHierachy: anObject	self removeDependent: anObject.	self tests do: [ :each | each removeDependentFromHierachy: anObject]			! !!TestSuite methodsFor: 'running' stamp: 'md 2/22/2006 14:27'!run	| result | 	result := TestResult new.	self resources do: [ :res |		res isAvailable ifFalse: [^res signalInitializationError]].	[self run: result] ensure: [self resources do: [:each | each reset]].	^result			! !!TestSuite methodsFor: 'running' stamp: 'md 2/22/2006 14:24'!run: aResult 	self tests do: [:each | 		self changed: each.		each run: aResult]			! !!TestSuite class methodsFor: 'instance creation'!named: aString	^self new		name: aString;		yourself			! !